{"ast":null,"code":"import axios from \"axios\";\nimport Store from \"../store/store\";\nexport function GetLocation() {\n  return new Promise((resolve, reject) => {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(location => resolve(location), error => reject(error));\n    }\n  });\n}\n\nfunction getOptions(options) {\n  // Get the current state of the client\n  let state = Store.getState(); // If we have a user anda session\n\n  if (state.user && Object.keys(state.user.user).length !== 0 && Object.keys(state.user.session).length !== 0) {\n    // Check if options already has headers,\n    // if not then create a new object\n    if (!options.headers) {\n      options.headers = {};\n    } // Set the user and token header for the server\n\n\n    options.headers[\"x-user-id\"] = state.user.user.id;\n    options.headers[\"x-token\"] = state.user.session.access_token;\n  } // return the options\n\n\n  return options;\n}\n\nfunction handleResponse(resolve, reject, options, response) {\n  // Check if something on the server went wrong,\n  // if something did go wrong then reject the promise\n  // and return the message\n  if (response.data.status === false) {\n    reject(response.data.message);\n  } // If nothing went wrong,\n  // check to see if the call wants the full response,\n  // if so resolve the full response,\n\n\n  if (options.full) {\n    resolve(response);\n  } // otherwise resolve only the data of the response\n  else {\n      resolve(response.data);\n    }\n}\n\nexport function get(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.get(url, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}\nexport function post(url, body, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.post(url, body, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}\nexport function put(url, body, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.put(url, body, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}","map":{"version":3,"sources":["/Users/austin/dev/fish-maps/ui/classes/Plugins.ts"],"names":["axios","Store","GetLocation","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","location","error","getOptions","options","state","getState","user","Object","keys","length","session","headers","id","access_token","handleResponse","response","data","status","message","full","get","url","then","post","body","put"],"mappings":"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","sourcesContent":["import axios from \"axios\"\nimport Store from \"../store/store\"\n\nexport function GetLocation(): Promise<Position> {\n\treturn new Promise((resolve, reject) => {\n\t\tif (navigator.geolocation) {\n\t\t\tnavigator.geolocation.getCurrentPosition(\n\t\t\t\t(location) => resolve(location),\n\t\t\t\t(error) => reject(error)\n\t\t\t)\n\t\t}\n\t})\n}\n\nfunction getOptions(options) {\n\t// Get the current state of the client\n\tlet state = Store.getState()\n\n\t// If we have a user anda session\n\tif (\n\t\tstate.user &&\n\t\tObject.keys(state.user.user).length !== 0 &&\n\t\tObject.keys(state.user.session).length !== 0\n\t) {\n\t\t// Check if options already has headers,\n\t\t// if not then create a new object\n\t\tif (!options.headers) {\n\t\t\toptions.headers = {}\n\t\t}\n\n\t\t// Set the user and token header for the server\n\t\toptions.headers[\"x-user-id\"] = state.user.user.id\n\t\toptions.headers[\"x-token\"] = state.user.session.access_token\n\t}\n\n\t// return the options\n\treturn options\n}\n\nfunction handleResponse(resolve, reject, options, response) {\n\t// Check if something on the server went wrong,\n\t// if something did go wrong then reject the promise\n\t// and return the message\n\tif (response.data.status === false) {\n\t\treject(response.data.message)\n\t}\n\n\t// If nothing went wrong,\n\t// check to see if the call wants the full response,\n\t// if so resolve the full response,\n\tif (options.full) {\n\t\tresolve(response)\n\t}\n\t// otherwise resolve only the data of the response\n\telse {\n\t\tresolve(response.data)\n\t}\n}\n\nexport function get(url, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.get(url, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n\nexport function post(url, body, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.post(url, body, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n\nexport function put(url, body, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.put(url, body, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n"]},"metadata":{},"sourceType":"module"}