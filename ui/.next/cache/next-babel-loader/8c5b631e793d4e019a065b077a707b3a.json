{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport default class EXIF {\n  constructor() {\n    _defineProperty(this, \"debug\", false);\n\n    _defineProperty(this, \"ExifTags\", {\n      // version tags\n      0x9000: \"ExifVersion\",\n      // EXIF version\n      0xa000: \"FlashpixVersion\",\n      // Flashpix format version\n      // colorspace tags\n      0xa001: \"ColorSpace\",\n      // Color space information tag\n      // image configuration\n      0xa002: \"PixelXDimension\",\n      // Valid width of meaningful image\n      0xa003: \"PixelYDimension\",\n      // Valid height of meaningful image\n      0x9101: \"ComponentsConfiguration\",\n      // Information about channels\n      0x9102: \"CompressedBitsPerPixel\",\n      // Compressed bits per pixel\n      // user information\n      0x927c: \"MakerNote\",\n      // Any desired information written by the manufacturer\n      0x9286: \"UserComment\",\n      // Comments by user\n      // related file\n      0xa004: \"RelatedSoundFile\",\n      // Name of related sound file\n      // date and time\n      0x9003: \"DateTimeOriginal\",\n      // Date and time when the original image was generated\n      0x9004: \"DateTimeDigitized\",\n      // Date and time when the image was stored digitally\n      0x9290: \"SubsecTime\",\n      // Fractions of seconds for DateTime\n      0x9291: \"SubsecTimeOriginal\",\n      // Fractions of seconds for DateTimeOriginal\n      0x9292: \"SubsecTimeDigitized\",\n      // Fractions of seconds for DateTimeDigitized\n      // picture-taking conditions\n      0x829a: \"ExposureTime\",\n      // Exposure time (in seconds)\n      0x829d: \"FNumber\",\n      // F number\n      0x8822: \"ExposureProgram\",\n      // Exposure program\n      0x8824: \"SpectralSensitivity\",\n      // Spectral sensitivity\n      0x8827: \"ISOSpeedRatings\",\n      // ISO speed rating\n      0x8828: \"OECF\",\n      // Optoelectric conversion factor\n      0x9201: \"ShutterSpeedValue\",\n      // Shutter speed\n      0x9202: \"ApertureValue\",\n      // Lens aperture\n      0x9203: \"BrightnessValue\",\n      // Value of brightness\n      0x9204: \"ExposureBias\",\n      // Exposure bias\n      0x9205: \"MaxApertureValue\",\n      // Smallest F number of lens\n      0x9206: \"SubjectDistance\",\n      // Distance to subject in meters\n      0x9207: \"MeteringMode\",\n      // Metering mode\n      0x9208: \"LightSource\",\n      // Kind of light source\n      0x9209: \"Flash\",\n      // Flash status\n      0x9214: \"SubjectArea\",\n      // Location and area of main subject\n      0x920a: \"FocalLength\",\n      // Focal length of the lens in mm\n      0xa20b: \"FlashEnergy\",\n      // Strobe energy in BCPS\n      0xa20c: \"SpatialFrequencyResponse\",\n      //\n      0xa20e: \"FocalPlaneXResolution\",\n      // Number of pixels in width direction per FocalPlaneResolutionUnit\n      0xa20f: \"FocalPlaneYResolution\",\n      // Number of pixels in height direction per FocalPlaneResolutionUnit\n      0xa210: \"FocalPlaneResolutionUnit\",\n      // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n      0xa214: \"SubjectLocation\",\n      // Location of subject in image\n      0xa215: \"ExposureIndex\",\n      // Exposure index selected on camera\n      0xa217: \"SensingMethod\",\n      // Image sensor type\n      0xa300: \"FileSource\",\n      // Image source (3 == DSC)\n      0xa301: \"SceneType\",\n      // Scene type (1 == directly photographed)\n      0xa302: \"CFAPattern\",\n      // Color filter array geometric pattern\n      0xa401: \"CustomRendered\",\n      // Special processing\n      0xa402: \"ExposureMode\",\n      // Exposure mode\n      0xa403: \"WhiteBalance\",\n      // 1 = auto white balance, 2 = manual\n      0xa404: \"DigitalZoomRation\",\n      // Digital zoom ratio\n      0xa405: \"FocalLengthIn35mmFilm\",\n      // Equivalent foacl length assuming 35mm film camera (in mm)\n      0xa406: \"SceneCaptureType\",\n      // Type of scene\n      0xa407: \"GainControl\",\n      // Degree of overall image gain adjustment\n      0xa408: \"Contrast\",\n      // Direction of contrast processing applied by camera\n      0xa409: \"Saturation\",\n      // Direction of saturation processing applied by camera\n      0xa40a: \"Sharpness\",\n      // Direction of sharpness processing applied by camera\n      0xa40b: \"DeviceSettingDescription\",\n      //\n      0xa40c: \"SubjectDistanceRange\",\n      // Distance to subject\n      // other tags\n      0xa005: \"InteroperabilityIFDPointer\",\n      0xa420: \"ImageUniqueID\" // Identifier assigned uniquely to each image\n\n    });\n\n    _defineProperty(this, \"TiffTags\", {\n      0x0100: \"ImageWidth\",\n      0x0101: \"ImageHeight\",\n      0x8769: \"ExifIFDPointer\",\n      0x8825: \"GPSInfoIFDPointer\",\n      0xa005: \"InteroperabilityIFDPointer\",\n      0x0102: \"BitsPerSample\",\n      0x0103: \"Compression\",\n      0x0106: \"PhotometricInterpretation\",\n      0x0112: \"Orientation\",\n      0x0115: \"SamplesPerPixel\",\n      0x011c: \"PlanarConfiguration\",\n      0x0212: \"YCbCrSubSampling\",\n      0x0213: \"YCbCrPositioning\",\n      0x011a: \"XResolution\",\n      0x011b: \"YResolution\",\n      0x0128: \"ResolutionUnit\",\n      0x0111: \"StripOffsets\",\n      0x0116: \"RowsPerStrip\",\n      0x0117: \"StripByteCounts\",\n      0x0201: \"JPEGInterchangeFormat\",\n      0x0202: \"JPEGInterchangeFormatLength\",\n      0x012d: \"TransferFunction\",\n      0x013e: \"WhitePoint\",\n      0x013f: \"PrimaryChromaticities\",\n      0x0211: \"YCbCrCoefficients\",\n      0x0214: \"ReferenceBlackWhite\",\n      0x0132: \"DateTime\",\n      0x010e: \"ImageDescription\",\n      0x010f: \"Make\",\n      0x0110: \"Model\",\n      0x0131: \"Software\",\n      0x013b: \"Artist\",\n      0x8298: \"Copyright\"\n    });\n\n    _defineProperty(this, \"GPSTags\", {\n      0x0000: \"GPSVersionID\",\n      0x0001: \"GPSLatitudeRef\",\n      0x0002: \"GPSLatitude\",\n      0x0003: \"GPSLongitudeRef\",\n      0x0004: \"GPSLongitude\",\n      0x0005: \"GPSAltitudeRef\",\n      0x0006: \"GPSAltitude\",\n      0x0007: \"GPSTimeStamp\",\n      0x0008: \"GPSSatellites\",\n      0x0009: \"GPSStatus\",\n      0x000a: \"GPSMeasureMode\",\n      0x000b: \"GPSDOP\",\n      0x000c: \"GPSSpeedRef\",\n      0x000d: \"GPSSpeed\",\n      0x000e: \"GPSTrackRef\",\n      0x000f: \"GPSTrack\",\n      0x0010: \"GPSImgDirectionRef\",\n      0x0011: \"GPSImgDirection\",\n      0x0012: \"GPSMapDatum\",\n      0x0013: \"GPSDestLatitudeRef\",\n      0x0014: \"GPSDestLatitude\",\n      0x0015: \"GPSDestLongitudeRef\",\n      0x0016: \"GPSDestLongitude\",\n      0x0017: \"GPSDestBearingRef\",\n      0x0018: \"GPSDestBearing\",\n      0x0019: \"GPSDestDistanceRef\",\n      0x001a: \"GPSDestDistance\",\n      0x001b: \"GPSProcessingMethod\",\n      0x001c: \"GPSAreaInformation\",\n      0x001d: \"GPSDateStamp\",\n      0x001e: \"GPSDifferential\"\n    });\n\n    _defineProperty(this, \"StringValues\", {\n      ExposureProgram: {\n        0: \"Not defined\",\n        1: \"Manual\",\n        2: \"Normal program\",\n        3: \"Aperture priority\",\n        4: \"Shutter priority\",\n        5: \"Creative program\",\n        6: \"Action program\",\n        7: \"Portrait mode\",\n        8: \"Landscape mode\"\n      },\n      MeteringMode: {\n        0: \"Unknown\",\n        1: \"Average\",\n        2: \"CenterWeightedAverage\",\n        3: \"Spot\",\n        4: \"MultiSpot\",\n        5: \"Pattern\",\n        6: \"Partial\",\n        255: \"Other\"\n      },\n      LightSource: {\n        0: \"Unknown\",\n        1: \"Daylight\",\n        2: \"Fluorescent\",\n        3: \"Tungsten (incandescent light)\",\n        4: \"Flash\",\n        9: \"Fine weather\",\n        10: \"Cloudy weather\",\n        11: \"Shade\",\n        12: \"Daylight fluorescent (D 5700 - 7100K)\",\n        13: \"Day white fluorescent (N 4600 - 5400K)\",\n        14: \"Cool white fluorescent (W 3900 - 4500K)\",\n        15: \"White fluorescent (WW 3200 - 3700K)\",\n        17: \"Standard light A\",\n        18: \"Standard light B\",\n        19: \"Standard light C\",\n        20: \"D55\",\n        21: \"D65\",\n        22: \"D75\",\n        23: \"D50\",\n        24: \"ISO studio tungsten\",\n        255: \"Other\"\n      },\n      Flash: {\n        0x0000: \"Flash did not fire\",\n        0x0001: \"Flash fired\",\n        0x0005: \"Strobe return light not detected\",\n        0x0007: \"Strobe return light detected\",\n        0x0009: \"Flash fired, compulsory flash mode\",\n        0x000d: \"Flash fired, compulsory flash mode, return light not detected\",\n        0x000f: \"Flash fired, compulsory flash mode, return light detected\",\n        0x0010: \"Flash did not fire, compulsory flash mode\",\n        0x0018: \"Flash did not fire, auto mode\",\n        0x0019: \"Flash fired, auto mode\",\n        0x001d: \"Flash fired, auto mode, return light not detected\",\n        0x001f: \"Flash fired, auto mode, return light detected\",\n        0x0020: \"No flash function\",\n        0x0041: \"Flash fired, red-eye reduction mode\",\n        0x0045: \"Flash fired, red-eye reduction mode, return light not detected\",\n        0x0047: \"Flash fired, red-eye reduction mode, return light detected\",\n        0x0049: \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n        0x004d: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n        0x004f: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n        0x0059: \"Flash fired, auto mode, red-eye reduction mode\",\n        0x005d: \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n        0x005f: \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n      },\n      SensingMethod: {\n        1: \"Not defined\",\n        2: \"One-chip color area sensor\",\n        3: \"Two-chip color area sensor\",\n        4: \"Three-chip color area sensor\",\n        5: \"Color sequential area sensor\",\n        7: \"Trilinear sensor\",\n        8: \"Color sequential linear sensor\"\n      },\n      SceneCaptureType: {\n        0: \"Standard\",\n        1: \"Landscape\",\n        2: \"Portrait\",\n        3: \"Night scene\"\n      },\n      SceneType: {\n        1: \"Directly photographed\"\n      },\n      CustomRendered: {\n        0: \"Normal process\",\n        1: \"Custom process\"\n      },\n      WhiteBalance: {\n        0: \"Auto white balance\",\n        1: \"Manual white balance\"\n      },\n      GainControl: {\n        0: \"None\",\n        1: \"Low gain up\",\n        2: \"High gain up\",\n        3: \"Low gain down\",\n        4: \"High gain down\"\n      },\n      Contrast: {\n        0: \"Normal\",\n        1: \"Soft\",\n        2: \"Hard\"\n      },\n      Saturation: {\n        0: \"Normal\",\n        1: \"Low saturation\",\n        2: \"High saturation\"\n      },\n      Sharpness: {\n        0: \"Normal\",\n        1: \"Soft\",\n        2: \"Hard\"\n      },\n      SubjectDistanceRange: {\n        0: \"Unknown\",\n        1: \"Macro\",\n        2: \"Close view\",\n        3: \"Distant view\"\n      },\n      FileSource: {\n        3: \"DSC\"\n      },\n      Components: {\n        0: \"\",\n        1: \"Y\",\n        2: \"Cb\",\n        3: \"Cr\",\n        4: \"R\",\n        5: \"G\",\n        6: \"B\"\n      }\n    });\n\n    _defineProperty(this, \"IptcFieldMap\", {\n      0x78: \"caption\",\n      0x6e: \"credit\",\n      0x19: \"keywords\",\n      0x37: \"dateCreated\",\n      0x50: \"byline\",\n      0x55: \"bylineTitle\",\n      0x7a: \"captionWriter\",\n      0x69: \"headline\",\n      0x74: \"copyright\",\n      0x0f: \"category\"\n    });\n  }\n\n  addEvent(element, event, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(event, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + event, handler);\n    }\n  }\n\n  imageHasData(img) {\n    return !!img.exifdata;\n  }\n\n  base64ToArrayBuffer(base64, contentType) {\n    contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/im)[1] || \"\"; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n\n    base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gim, \"\");\n    let binary = atob(base64);\n    let len = binary.length;\n    let buffer = new ArrayBuffer(len);\n    let view = new Uint8Array(buffer);\n\n    for (let i = 0; i < len; i++) {\n      view[i] = binary.charCodeAt(i);\n    }\n\n    return buffer;\n  }\n\n  objectURLToBlob(url, callback) {\n    let http = new XMLHttpRequest();\n    http.open(\"GET\", url, true);\n    http.responseType = \"blob\";\n\n    http.onload = function (e) {\n      if (this.status == 200 || this.status === 0) {\n        callback(this.response);\n      }\n    };\n\n    http.send();\n  }\n\n  getImageData(img, callback) {\n    function handleBinaryFile(binFile) {\n      let data = findEXIFinJPEG(binFile);\n      let iptcdata = findIPTCinJPEG(binFile);\n      img.exifdata = data || {};\n      img.iptcdata = iptcdata || {};\n\n      if (callback) {\n        callback.call(img);\n      }\n    }\n\n    if (img instanceof Image || img instanceof HTMLImageElement) {\n      if (/^data\\:/i.test(img.src)) {\n        // Data URI\n        let arrayBuffer = base64ToArrayBuffer(img.src);\n        handleBinaryFile(arrayBuffer);\n      } else if (/^blob\\:/i.test(img.src)) {\n        // Object URL\n        let fileReader = new FileReader();\n\n        fileReader.onload = function (e) {\n          handleBinaryFile(e.target.result);\n        };\n\n        objectURLToBlob(img.src, function (blob) {\n          fileReader.readAsArrayBuffer(blob);\n        });\n      } else {\n        let http = new XMLHttpRequest();\n\n        http.onload = function () {\n          if (http.status == \"200\") {\n            handleBinaryFile(http.response);\n          } else {\n            throw \"Could not load image\";\n          }\n\n          http = null;\n        };\n\n        http.open(\"GET\", img.src, true);\n        http.responseType = \"arraybuffer\";\n        http.send(null);\n      }\n    } else if (window.FileReader && (img instanceof window.Blob || img instanceof window.File)) {\n      let fileReader = new FileReader();\n\n      fileReader.onload = function (e) {\n        if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n        handleBinaryFile(e.target.result);\n      };\n\n      fileReader.readAsArrayBuffer(img);\n    }\n  }\n\n  findEXIFinJPEG(file) {\n    let dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n\n    if (dataView.getUint8(0) != 0xff || dataView.getUint8(1) != 0xd8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n\n    let offset = 2,\n        length = file.byteLength,\n        marker;\n\n    while (offset < length) {\n      if (dataView.getUint8(offset) != 0xff) {\n        if (debug) {\n          console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n        }\n\n        return false; // not a valid marker, something is wrong\n      }\n\n      marker = dataView.getUint8(offset + 1);\n\n      if (debug) {\n        console.log(marker);\n      } // we could implement handling for other markers here,\n      // but we're only looking for 0xFFE1 for EXIF data\n\n\n      if (marker == 225) {\n        if (debug) console.log(\"Found 0xFFE1 marker\");\n        return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n      } else {\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    }\n  }\n\n  isFieldSegmentStart(dataView, offset) {\n    return dataView.getUint8(offset) === 0x38 && dataView.getUint8(offset + 1) === 0x42 && dataView.getUint8(offset + 2) === 0x49 && dataView.getUint8(offset + 3) === 0x4d && dataView.getUint8(offset + 4) === 0x04 && dataView.getUint8(offset + 5) === 0x04;\n  }\n\n  findIPTCinJPEG(file) {\n    let dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n\n    if (dataView.getUint8(0) != 0xff || dataView.getUint8(1) != 0xd8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n\n    let offset = 2,\n        length = file.byteLength;\n\n    while (offset < length) {\n      if (this.isFieldSegmentStart(dataView, offset)) {\n        // Get the length of the name header (which is padded to an even number of bytes)\n        let nameHeaderLength = dataView.getUint8(offset + 7);\n\n        if (nameHeaderLength % 2 !== 0) {\n          nameHeaderLength += 1;\n        } // Check for pre photoshop 6 format\n\n\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4;\n        }\n\n        let startOffset = offset + 8 + nameHeaderLength;\n        let sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n        return readIPTCData(file, startOffset, sectionLength);\n      } // Not the marker, continue searching\n\n\n      offset++;\n    }\n  }\n\n  readIPTCData(file, startOffset, sectionLength) {\n    let data = {};\n    let dataView = new DataView(file);\n    let segmentStartPos = startOffset;\n    let fieldValue, fieldName, dataSize, segmentType, segmentSize;\n\n    while (segmentStartPos < startOffset + sectionLength) {\n      if (dataView.getUint8(segmentStartPos) === 0x1c && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n        segmentType = dataView.getUint8(segmentStartPos + 2);\n\n        if (segmentType in IptcFieldMap) {\n          dataSize = dataView.getInt16(segmentStartPos + 3);\n          segmentSize = dataSize + 5;\n          fieldName = IptcFieldMap[segmentType];\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize); // Check if we already stored a value with this name\n\n          if (data.hasOwnProperty(fieldName)) {\n            // Value already stored with this name, create multivalue field\n            if (data[fieldName] instanceof Array) {\n              data[fieldName].push(fieldValue);\n            } else {\n              data[fieldName] = [data[fieldName], fieldValue];\n            }\n          } else {\n            data[fieldName] = fieldValue;\n          }\n        }\n      }\n\n      segmentStartPos++;\n    }\n\n    return data;\n  }\n\n  readTags(file, tiffStart, dirStart, strings, bigEnd) {\n    let entries = file.getUint16(dirStart, !bigEnd),\n        tags = {},\n        entryOffset,\n        tag,\n        i;\n\n    for (i = 0; i < entries; i++) {\n      entryOffset = dirStart + i * 12 + 2;\n      tag = strings[file.getUint16(entryOffset, !bigEnd)];\n\n      if (!tag && debug) {\n        console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n      }\n\n      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n    }\n\n    return tags;\n  }\n\n  readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n    let type = file.getUint16(entryOffset + 2, !bigEnd),\n        numValues = file.getUint32(entryOffset + 4, !bigEnd),\n        valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart,\n        offset,\n        vals,\n        val,\n        n,\n        numerator,\n        denominator;\n\n    switch (type) {\n      case 1: // byte, 8-bit unsigned int\n\n      case 7:\n        // undefined, 8-bit byte, value depending on field\n        if (numValues == 1) {\n          return file.getUint8(entryOffset + 8, !bigEnd);\n        } else {\n          offset = numValues > 4 ? valueOffset : entryOffset + 8;\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint8(offset + n);\n          }\n\n          return vals;\n        }\n\n      case 2:\n        // ascii, 8-bit byte\n        offset = numValues > 4 ? valueOffset : entryOffset + 8;\n        return getStringFromDB(file, offset, numValues - 1);\n\n      case 3:\n        // short, 16 bit int\n        if (numValues == 1) {\n          return file.getUint16(entryOffset + 8, !bigEnd);\n        } else {\n          offset = numValues > 2 ? valueOffset : entryOffset + 8;\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint16(offset + 2 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n      case 4:\n        // long, 32 bit int\n        if (numValues == 1) {\n          return file.getUint32(entryOffset + 8, !bigEnd);\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n      case 5:\n        // rational = two long values, first is numerator, second is denominator\n        if (numValues == 1) {\n          numerator = file.getUint32(valueOffset, !bigEnd);\n          denominator = file.getUint32(valueOffset + 4, !bigEnd);\n          val = new Number(numerator / denominator);\n          val.numerator = numerator;\n          val.denominator = denominator;\n          return val;\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);\n            denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);\n            vals[n] = new Number(numerator / denominator);\n            vals[n].numerator = numerator;\n            vals[n].denominator = denominator;\n          }\n\n          return vals;\n        }\n\n      case 9:\n        // slong, 32 bit signed int\n        if (numValues == 1) {\n          return file.getInt32(entryOffset + 8, !bigEnd);\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n      case 10:\n        // signed rational, two slongs, first is numerator, second is denominator\n        if (numValues == 1) {\n          return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);\n        } else {\n          vals = [];\n\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);\n          }\n\n          return vals;\n        }\n\n    }\n  }\n\n  getStringFromDB(buffer, start, length) {\n    let outstr = \"\";\n\n    for (n = start; n < start + length; n++) {\n      outstr += String.fromCharCode(buffer.getUint8(n));\n    }\n\n    return outstr;\n  }\n\n  readEXIFData(file, start) {\n    if (getStringFromDB(file, start, 4) != \"Exif\") {\n      if (debug) {\n        console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n      }\n\n      return false;\n    }\n\n    let bigEnd,\n        tags,\n        tag,\n        exifData,\n        gpsData,\n        tiffOffset = start + 6; // test for TIFF validity and endianness\n\n    if (file.getUint16(tiffOffset) == 0x4949) {\n      bigEnd = false;\n    } else if (file.getUint16(tiffOffset) == 0x4d4d) {\n      bigEnd = true;\n    } else {\n      if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n      return false;\n    }\n\n    if (file.getUint16(tiffOffset + 2, !bigEnd) != 0x002a) {\n      if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n      return false;\n    }\n\n    let firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\n\n    if (firstIFDOffset < 0x00000008) {\n      if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset + 4, !bigEnd));\n      return false;\n    }\n\n    tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n    if (tags.ExifIFDPointer) {\n      exifData = this.readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n\n      for (tag in exifData) {\n        switch (tag) {\n          case \"LightSource\":\n          case \"Flash\":\n          case \"MeteringMode\":\n          case \"ExposureProgram\":\n          case \"SensingMethod\":\n          case \"SceneCaptureType\":\n          case \"SceneType\":\n          case \"CustomRendered\":\n          case \"WhiteBalance\":\n          case \"GainControl\":\n          case \"Contrast\":\n          case \"Saturation\":\n          case \"Sharpness\":\n          case \"SubjectDistanceRange\":\n          case \"FileSource\":\n            exifData[tag] = StringValues[tag][exifData[tag]];\n            break;\n\n          case \"ExifVersion\":\n          case \"FlashpixVersion\":\n            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n            break;\n\n          case \"ComponentsConfiguration\":\n            exifData[tag] = StringValues.Components[exifData[tag][0]] + StringValues.Components[exifData[tag][1]] + StringValues.Components[exifData[tag][2]] + StringValues.Components[exifData[tag][3]];\n            break;\n        }\n\n        tags[tag] = exifData[tag];\n      }\n    }\n\n    if (tags.GPSInfoIFDPointer) {\n      gpsData = this.readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n\n      for (tag in gpsData) {\n        switch (tag) {\n          case \"GPSVersionID\":\n            gpsData[tag] = gpsData[tag][0] + \".\" + gpsData[tag][1] + \".\" + gpsData[tag][2] + \".\" + gpsData[tag][3];\n            break;\n        }\n\n        tags[tag] = gpsData[tag];\n      }\n    }\n\n    return tags;\n  }\n\n  getData(img, callback) {\n    if ((img instanceof Image || img instanceof HTMLImageElement) && !img.complete) return false;\n\n    if (!this.imageHasData(img)) {\n      this.getImageData(img, callback);\n    } else {\n      if (callback) {\n        callback.call(img);\n      }\n    }\n\n    return true;\n  }\n\n  getTag(img, tag) {\n    if (!this.imageHasData(img)) return;\n    return img.exifdata[tag];\n  }\n\n  getAllTags(img) {\n    if (!this.imageHasData(img)) return {};\n    let a,\n        data = img.exifdata,\n        tags = {};\n\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        tags[a] = data[a];\n      }\n    }\n\n    return tags;\n  }\n\n  pretty(img) {\n    if (!this.imageHasData(img)) return \"\";\n    let a,\n        data = img.exifdata,\n        strPretty = \"\";\n\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        if (typeof data[a] == \"object\") {\n          if (data[a] instanceof Number) {\n            strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n          } else {\n            strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n          }\n        } else {\n          strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n        }\n      }\n    }\n\n    return strPretty;\n  }\n\n  readFromBinaryFile(file) {\n    return this.findEXIFinJPEG(file);\n  }\n\n}","map":{"version":3,"sources":["/Users/austin/dev/fish-maps/ui/classes/EXIF.js"],"names":["EXIF","ExposureProgram","MeteringMode","LightSource","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","addEvent","element","event","handler","addEventListener","attachEvent","imageHasData","img","exifdata","base64ToArrayBuffer","base64","contentType","match","replace","binary","atob","len","length","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","objectURLToBlob","url","callback","http","XMLHttpRequest","open","responseType","onload","e","status","response","send","getImageData","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","findIPTCinJPEG","call","Image","HTMLImageElement","test","src","arrayBuffer","fileReader","FileReader","target","result","blob","readAsArrayBuffer","window","Blob","File","debug","console","log","byteLength","file","dataView","DataView","getUint8","offset","marker","readEXIFData","getUint16","isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","readIPTCData","segmentStartPos","fieldValue","fieldName","dataSize","segmentType","segmentSize","IptcFieldMap","getInt16","getStringFromDB","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entries","tags","entryOffset","tag","readTagValue","type","numValues","getUint32","valueOffset","vals","val","n","numerator","denominator","Number","getInt32","start","outstr","String","fromCharCode","exifData","gpsData","tiffOffset","firstIFDOffset","TiffTags","ExifIFDPointer","ExifTags","StringValues","GPSInfoIFDPointer","GPSTags","getData","complete","getTag","getAllTags","a","pretty","strPretty","readFromBinaryFile"],"mappings":"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","sourcesContent":["export default class EXIF {\n\tdebug = false\n\n\tExifTags = {\n\t\t// version tags\n\t\t0x9000: \"ExifVersion\", // EXIF version\n\t\t0xa000: \"FlashpixVersion\", // Flashpix format version\n\n\t\t// colorspace tags\n\t\t0xa001: \"ColorSpace\", // Color space information tag\n\n\t\t// image configuration\n\t\t0xa002: \"PixelXDimension\", // Valid width of meaningful image\n\t\t0xa003: \"PixelYDimension\", // Valid height of meaningful image\n\t\t0x9101: \"ComponentsConfiguration\", // Information about channels\n\t\t0x9102: \"CompressedBitsPerPixel\", // Compressed bits per pixel\n\n\t\t// user information\n\t\t0x927c: \"MakerNote\", // Any desired information written by the manufacturer\n\t\t0x9286: \"UserComment\", // Comments by user\n\n\t\t// related file\n\t\t0xa004: \"RelatedSoundFile\", // Name of related sound file\n\n\t\t// date and time\n\t\t0x9003: \"DateTimeOriginal\", // Date and time when the original image was generated\n\t\t0x9004: \"DateTimeDigitized\", // Date and time when the image was stored digitally\n\t\t0x9290: \"SubsecTime\", // Fractions of seconds for DateTime\n\t\t0x9291: \"SubsecTimeOriginal\", // Fractions of seconds for DateTimeOriginal\n\t\t0x9292: \"SubsecTimeDigitized\", // Fractions of seconds for DateTimeDigitized\n\n\t\t// picture-taking conditions\n\t\t0x829a: \"ExposureTime\", // Exposure time (in seconds)\n\t\t0x829d: \"FNumber\", // F number\n\t\t0x8822: \"ExposureProgram\", // Exposure program\n\t\t0x8824: \"SpectralSensitivity\", // Spectral sensitivity\n\t\t0x8827: \"ISOSpeedRatings\", // ISO speed rating\n\t\t0x8828: \"OECF\", // Optoelectric conversion factor\n\t\t0x9201: \"ShutterSpeedValue\", // Shutter speed\n\t\t0x9202: \"ApertureValue\", // Lens aperture\n\t\t0x9203: \"BrightnessValue\", // Value of brightness\n\t\t0x9204: \"ExposureBias\", // Exposure bias\n\t\t0x9205: \"MaxApertureValue\", // Smallest F number of lens\n\t\t0x9206: \"SubjectDistance\", // Distance to subject in meters\n\t\t0x9207: \"MeteringMode\", // Metering mode\n\t\t0x9208: \"LightSource\", // Kind of light source\n\t\t0x9209: \"Flash\", // Flash status\n\t\t0x9214: \"SubjectArea\", // Location and area of main subject\n\t\t0x920a: \"FocalLength\", // Focal length of the lens in mm\n\t\t0xa20b: \"FlashEnergy\", // Strobe energy in BCPS\n\t\t0xa20c: \"SpatialFrequencyResponse\", //\n\t\t0xa20e: \"FocalPlaneXResolution\", // Number of pixels in width direction per FocalPlaneResolutionUnit\n\t\t0xa20f: \"FocalPlaneYResolution\", // Number of pixels in height direction per FocalPlaneResolutionUnit\n\t\t0xa210: \"FocalPlaneResolutionUnit\", // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n\t\t0xa214: \"SubjectLocation\", // Location of subject in image\n\t\t0xa215: \"ExposureIndex\", // Exposure index selected on camera\n\t\t0xa217: \"SensingMethod\", // Image sensor type\n\t\t0xa300: \"FileSource\", // Image source (3 == DSC)\n\t\t0xa301: \"SceneType\", // Scene type (1 == directly photographed)\n\t\t0xa302: \"CFAPattern\", // Color filter array geometric pattern\n\t\t0xa401: \"CustomRendered\", // Special processing\n\t\t0xa402: \"ExposureMode\", // Exposure mode\n\t\t0xa403: \"WhiteBalance\", // 1 = auto white balance, 2 = manual\n\t\t0xa404: \"DigitalZoomRation\", // Digital zoom ratio\n\t\t0xa405: \"FocalLengthIn35mmFilm\", // Equivalent foacl length assuming 35mm film camera (in mm)\n\t\t0xa406: \"SceneCaptureType\", // Type of scene\n\t\t0xa407: \"GainControl\", // Degree of overall image gain adjustment\n\t\t0xa408: \"Contrast\", // Direction of contrast processing applied by camera\n\t\t0xa409: \"Saturation\", // Direction of saturation processing applied by camera\n\t\t0xa40a: \"Sharpness\", // Direction of sharpness processing applied by camera\n\t\t0xa40b: \"DeviceSettingDescription\", //\n\t\t0xa40c: \"SubjectDistanceRange\", // Distance to subject\n\n\t\t// other tags\n\t\t0xa005: \"InteroperabilityIFDPointer\",\n\t\t0xa420: \"ImageUniqueID\", // Identifier assigned uniquely to each image\n\t}\n\n\tTiffTags = {\n\t\t0x0100: \"ImageWidth\",\n\t\t0x0101: \"ImageHeight\",\n\t\t0x8769: \"ExifIFDPointer\",\n\t\t0x8825: \"GPSInfoIFDPointer\",\n\t\t0xa005: \"InteroperabilityIFDPointer\",\n\t\t0x0102: \"BitsPerSample\",\n\t\t0x0103: \"Compression\",\n\t\t0x0106: \"PhotometricInterpretation\",\n\t\t0x0112: \"Orientation\",\n\t\t0x0115: \"SamplesPerPixel\",\n\t\t0x011c: \"PlanarConfiguration\",\n\t\t0x0212: \"YCbCrSubSampling\",\n\t\t0x0213: \"YCbCrPositioning\",\n\t\t0x011a: \"XResolution\",\n\t\t0x011b: \"YResolution\",\n\t\t0x0128: \"ResolutionUnit\",\n\t\t0x0111: \"StripOffsets\",\n\t\t0x0116: \"RowsPerStrip\",\n\t\t0x0117: \"StripByteCounts\",\n\t\t0x0201: \"JPEGInterchangeFormat\",\n\t\t0x0202: \"JPEGInterchangeFormatLength\",\n\t\t0x012d: \"TransferFunction\",\n\t\t0x013e: \"WhitePoint\",\n\t\t0x013f: \"PrimaryChromaticities\",\n\t\t0x0211: \"YCbCrCoefficients\",\n\t\t0x0214: \"ReferenceBlackWhite\",\n\t\t0x0132: \"DateTime\",\n\t\t0x010e: \"ImageDescription\",\n\t\t0x010f: \"Make\",\n\t\t0x0110: \"Model\",\n\t\t0x0131: \"Software\",\n\t\t0x013b: \"Artist\",\n\t\t0x8298: \"Copyright\",\n\t}\n\n\tGPSTags = {\n\t\t0x0000: \"GPSVersionID\",\n\t\t0x0001: \"GPSLatitudeRef\",\n\t\t0x0002: \"GPSLatitude\",\n\t\t0x0003: \"GPSLongitudeRef\",\n\t\t0x0004: \"GPSLongitude\",\n\t\t0x0005: \"GPSAltitudeRef\",\n\t\t0x0006: \"GPSAltitude\",\n\t\t0x0007: \"GPSTimeStamp\",\n\t\t0x0008: \"GPSSatellites\",\n\t\t0x0009: \"GPSStatus\",\n\t\t0x000a: \"GPSMeasureMode\",\n\t\t0x000b: \"GPSDOP\",\n\t\t0x000c: \"GPSSpeedRef\",\n\t\t0x000d: \"GPSSpeed\",\n\t\t0x000e: \"GPSTrackRef\",\n\t\t0x000f: \"GPSTrack\",\n\t\t0x0010: \"GPSImgDirectionRef\",\n\t\t0x0011: \"GPSImgDirection\",\n\t\t0x0012: \"GPSMapDatum\",\n\t\t0x0013: \"GPSDestLatitudeRef\",\n\t\t0x0014: \"GPSDestLatitude\",\n\t\t0x0015: \"GPSDestLongitudeRef\",\n\t\t0x0016: \"GPSDestLongitude\",\n\t\t0x0017: \"GPSDestBearingRef\",\n\t\t0x0018: \"GPSDestBearing\",\n\t\t0x0019: \"GPSDestDistanceRef\",\n\t\t0x001a: \"GPSDestDistance\",\n\t\t0x001b: \"GPSProcessingMethod\",\n\t\t0x001c: \"GPSAreaInformation\",\n\t\t0x001d: \"GPSDateStamp\",\n\t\t0x001e: \"GPSDifferential\",\n\t}\n\n\tStringValues = {\n\t\tExposureProgram: {\n\t\t\t0: \"Not defined\",\n\t\t\t1: \"Manual\",\n\t\t\t2: \"Normal program\",\n\t\t\t3: \"Aperture priority\",\n\t\t\t4: \"Shutter priority\",\n\t\t\t5: \"Creative program\",\n\t\t\t6: \"Action program\",\n\t\t\t7: \"Portrait mode\",\n\t\t\t8: \"Landscape mode\",\n\t\t},\n\t\tMeteringMode: {\n\t\t\t0: \"Unknown\",\n\t\t\t1: \"Average\",\n\t\t\t2: \"CenterWeightedAverage\",\n\t\t\t3: \"Spot\",\n\t\t\t4: \"MultiSpot\",\n\t\t\t5: \"Pattern\",\n\t\t\t6: \"Partial\",\n\t\t\t255: \"Other\",\n\t\t},\n\t\tLightSource: {\n\t\t\t0: \"Unknown\",\n\t\t\t1: \"Daylight\",\n\t\t\t2: \"Fluorescent\",\n\t\t\t3: \"Tungsten (incandescent light)\",\n\t\t\t4: \"Flash\",\n\t\t\t9: \"Fine weather\",\n\t\t\t10: \"Cloudy weather\",\n\t\t\t11: \"Shade\",\n\t\t\t12: \"Daylight fluorescent (D 5700 - 7100K)\",\n\t\t\t13: \"Day white fluorescent (N 4600 - 5400K)\",\n\t\t\t14: \"Cool white fluorescent (W 3900 - 4500K)\",\n\t\t\t15: \"White fluorescent (WW 3200 - 3700K)\",\n\t\t\t17: \"Standard light A\",\n\t\t\t18: \"Standard light B\",\n\t\t\t19: \"Standard light C\",\n\t\t\t20: \"D55\",\n\t\t\t21: \"D65\",\n\t\t\t22: \"D75\",\n\t\t\t23: \"D50\",\n\t\t\t24: \"ISO studio tungsten\",\n\t\t\t255: \"Other\",\n\t\t},\n\t\tFlash: {\n\t\t\t0x0000: \"Flash did not fire\",\n\t\t\t0x0001: \"Flash fired\",\n\t\t\t0x0005: \"Strobe return light not detected\",\n\t\t\t0x0007: \"Strobe return light detected\",\n\t\t\t0x0009: \"Flash fired, compulsory flash mode\",\n\t\t\t0x000d: \"Flash fired, compulsory flash mode, return light not detected\",\n\t\t\t0x000f: \"Flash fired, compulsory flash mode, return light detected\",\n\t\t\t0x0010: \"Flash did not fire, compulsory flash mode\",\n\t\t\t0x0018: \"Flash did not fire, auto mode\",\n\t\t\t0x0019: \"Flash fired, auto mode\",\n\t\t\t0x001d: \"Flash fired, auto mode, return light not detected\",\n\t\t\t0x001f: \"Flash fired, auto mode, return light detected\",\n\t\t\t0x0020: \"No flash function\",\n\t\t\t0x0041: \"Flash fired, red-eye reduction mode\",\n\t\t\t0x0045: \"Flash fired, red-eye reduction mode, return light not detected\",\n\t\t\t0x0047: \"Flash fired, red-eye reduction mode, return light detected\",\n\t\t\t0x0049: \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n\t\t\t0x004d: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n\t\t\t0x004f: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n\t\t\t0x0059: \"Flash fired, auto mode, red-eye reduction mode\",\n\t\t\t0x005d: \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n\t\t\t0x005f: \"Flash fired, auto mode, return light detected, red-eye reduction mode\",\n\t\t},\n\t\tSensingMethod: {\n\t\t\t1: \"Not defined\",\n\t\t\t2: \"One-chip color area sensor\",\n\t\t\t3: \"Two-chip color area sensor\",\n\t\t\t4: \"Three-chip color area sensor\",\n\t\t\t5: \"Color sequential area sensor\",\n\t\t\t7: \"Trilinear sensor\",\n\t\t\t8: \"Color sequential linear sensor\",\n\t\t},\n\t\tSceneCaptureType: {\n\t\t\t0: \"Standard\",\n\t\t\t1: \"Landscape\",\n\t\t\t2: \"Portrait\",\n\t\t\t3: \"Night scene\",\n\t\t},\n\t\tSceneType: {\n\t\t\t1: \"Directly photographed\",\n\t\t},\n\t\tCustomRendered: {\n\t\t\t0: \"Normal process\",\n\t\t\t1: \"Custom process\",\n\t\t},\n\t\tWhiteBalance: {\n\t\t\t0: \"Auto white balance\",\n\t\t\t1: \"Manual white balance\",\n\t\t},\n\t\tGainControl: {\n\t\t\t0: \"None\",\n\t\t\t1: \"Low gain up\",\n\t\t\t2: \"High gain up\",\n\t\t\t3: \"Low gain down\",\n\t\t\t4: \"High gain down\",\n\t\t},\n\t\tContrast: {\n\t\t\t0: \"Normal\",\n\t\t\t1: \"Soft\",\n\t\t\t2: \"Hard\",\n\t\t},\n\t\tSaturation: {\n\t\t\t0: \"Normal\",\n\t\t\t1: \"Low saturation\",\n\t\t\t2: \"High saturation\",\n\t\t},\n\t\tSharpness: {\n\t\t\t0: \"Normal\",\n\t\t\t1: \"Soft\",\n\t\t\t2: \"Hard\",\n\t\t},\n\t\tSubjectDistanceRange: {\n\t\t\t0: \"Unknown\",\n\t\t\t1: \"Macro\",\n\t\t\t2: \"Close view\",\n\t\t\t3: \"Distant view\",\n\t\t},\n\t\tFileSource: {\n\t\t\t3: \"DSC\",\n\t\t},\n\n\t\tComponents: {\n\t\t\t0: \"\",\n\t\t\t1: \"Y\",\n\t\t\t2: \"Cb\",\n\t\t\t3: \"Cr\",\n\t\t\t4: \"R\",\n\t\t\t5: \"G\",\n\t\t\t6: \"B\",\n\t\t},\n\t}\n\n\taddEvent(element, event, handler) {\n\t\tif (element.addEventListener) {\n\t\t\telement.addEventListener(event, handler, false)\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent(\"on\" + event, handler)\n\t\t}\n\t}\n\n\timageHasData(img) {\n\t\treturn !!img.exifdata\n\t}\n\n\tbase64ToArrayBuffer(base64, contentType) {\n\t\tcontentType =\n\t\t\tcontentType || base64.match(/^data\\:([^\\;]+)\\;base64,/im)[1] || \"\" // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n\t\tbase64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gim, \"\")\n\t\tlet binary = atob(base64)\n\t\tlet len = binary.length\n\t\tlet buffer = new ArrayBuffer(len)\n\t\tlet view = new Uint8Array(buffer)\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tview[i] = binary.charCodeAt(i)\n\t\t}\n\t\treturn buffer\n\t}\n\n\tobjectURLToBlob(url, callback) {\n\t\tlet http = new XMLHttpRequest()\n\t\thttp.open(\"GET\", url, true)\n\t\thttp.responseType = \"blob\"\n\t\thttp.onload = function (e) {\n\t\t\tif (this.status == 200 || this.status === 0) {\n\t\t\t\tcallback(this.response)\n\t\t\t}\n\t\t}\n\t\thttp.send()\n\t}\n\n\tgetImageData(img, callback) {\n\t\tfunction handleBinaryFile(binFile) {\n\t\t\tlet data = findEXIFinJPEG(binFile)\n\t\t\tlet iptcdata = findIPTCinJPEG(binFile)\n\t\t\timg.exifdata = data || {}\n\t\t\timg.iptcdata = iptcdata || {}\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(img)\n\t\t\t}\n\t\t}\n\n\t\tif (img instanceof Image || img instanceof HTMLImageElement) {\n\t\t\tif (/^data\\:/i.test(img.src)) {\n\t\t\t\t// Data URI\n\t\t\t\tlet arrayBuffer = base64ToArrayBuffer(img.src)\n\t\t\t\thandleBinaryFile(arrayBuffer)\n\t\t\t} else if (/^blob\\:/i.test(img.src)) {\n\t\t\t\t// Object URL\n\t\t\t\tlet fileReader = new FileReader()\n\t\t\t\tfileReader.onload = function (e) {\n\t\t\t\t\thandleBinaryFile(e.target.result)\n\t\t\t\t}\n\t\t\t\tobjectURLToBlob(img.src, function (blob) {\n\t\t\t\t\tfileReader.readAsArrayBuffer(blob)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tlet http = new XMLHttpRequest()\n\t\t\t\thttp.onload = function () {\n\t\t\t\t\tif (http.status == \"200\") {\n\t\t\t\t\t\thandleBinaryFile(http.response)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Could not load image\"\n\t\t\t\t\t}\n\t\t\t\t\thttp = null\n\t\t\t\t}\n\t\t\t\thttp.open(\"GET\", img.src, true)\n\t\t\t\thttp.responseType = \"arraybuffer\"\n\t\t\t\thttp.send(null)\n\t\t\t}\n\t\t} else if (\n\t\t\twindow.FileReader &&\n\t\t\t(img instanceof window.Blob || img instanceof window.File)\n\t\t) {\n\t\t\tlet fileReader = new FileReader()\n\t\t\tfileReader.onload = function (e) {\n\t\t\t\tif (debug)\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\"Got file of length \" + e.target.result.byteLength\n\t\t\t\t\t)\n\t\t\t\thandleBinaryFile(e.target.result)\n\t\t\t}\n\n\t\t\tfileReader.readAsArrayBuffer(img)\n\t\t}\n\t}\n\n\tfindEXIFinJPEG(file) {\n\t\tlet dataView = new DataView(file)\n\n\t\tif (debug) console.log(\"Got file of length \" + file.byteLength)\n\t\tif (dataView.getUint8(0) != 0xff || dataView.getUint8(1) != 0xd8) {\n\t\t\tif (debug) console.log(\"Not a valid JPEG\")\n\t\t\treturn false // not a valid jpeg\n\t\t}\n\n\t\tlet offset = 2,\n\t\t\tlength = file.byteLength,\n\t\t\tmarker\n\n\t\twhile (offset < length) {\n\t\t\tif (dataView.getUint8(offset) != 0xff) {\n\t\t\t\tif (debug) {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\"Not a valid marker at offset \" +\n\t\t\t\t\t\t\toffset +\n\t\t\t\t\t\t\t\", found: \" +\n\t\t\t\t\t\t\tdataView.getUint8(offset)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\treturn false // not a valid marker, something is wrong\n\t\t\t}\n\n\t\t\tmarker = dataView.getUint8(offset + 1)\n\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(marker)\n\t\t\t}\n\n\t\t\t// we could implement handling for other markers here,\n\t\t\t// but we're only looking for 0xFFE1 for EXIF data\n\n\t\t\tif (marker == 225) {\n\t\t\t\tif (debug) console.log(\"Found 0xFFE1 marker\")\n\n\t\t\t\treturn readEXIFData(\n\t\t\t\t\tdataView,\n\t\t\t\t\toffset + 4,\n\t\t\t\t\tdataView.getUint16(offset + 2) - 2\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\toffset += 2 + dataView.getUint16(offset + 2)\n\t\t\t}\n\t\t}\n\t}\n\n\tisFieldSegmentStart(dataView, offset) {\n\t\treturn (\n\t\t\tdataView.getUint8(offset) === 0x38 &&\n\t\t\tdataView.getUint8(offset + 1) === 0x42 &&\n\t\t\tdataView.getUint8(offset + 2) === 0x49 &&\n\t\t\tdataView.getUint8(offset + 3) === 0x4d &&\n\t\t\tdataView.getUint8(offset + 4) === 0x04 &&\n\t\t\tdataView.getUint8(offset + 5) === 0x04\n\t\t)\n\t}\n\n\tfindIPTCinJPEG(file) {\n\t\tlet dataView = new DataView(file)\n\n\t\tif (debug) console.log(\"Got file of length \" + file.byteLength)\n\t\tif (dataView.getUint8(0) != 0xff || dataView.getUint8(1) != 0xd8) {\n\t\t\tif (debug) console.log(\"Not a valid JPEG\")\n\t\t\treturn false // not a valid jpeg\n\t\t}\n\n\t\tlet offset = 2,\n\t\t\tlength = file.byteLength\n\n\t\twhile (offset < length) {\n\t\t\tif (this.isFieldSegmentStart(dataView, offset)) {\n\t\t\t\t// Get the length of the name header (which is padded to an even number of bytes)\n\t\t\t\tlet nameHeaderLength = dataView.getUint8(offset + 7)\n\n\t\t\t\tif (nameHeaderLength % 2 !== 0) {\n\t\t\t\t\tnameHeaderLength += 1\n\t\t\t\t}\n\n\t\t\t\t// Check for pre photoshop 6 format\n\t\t\t\tif (nameHeaderLength === 0) {\n\t\t\t\t\t// Always 4\n\t\t\t\t\tnameHeaderLength = 4\n\t\t\t\t}\n\n\t\t\t\tlet startOffset = offset + 8 + nameHeaderLength\n\t\t\t\tlet sectionLength = dataView.getUint16(\n\t\t\t\t\toffset + 6 + nameHeaderLength\n\t\t\t\t)\n\n\t\t\t\treturn readIPTCData(file, startOffset, sectionLength)\n\t\t\t}\n\n\t\t\t// Not the marker, continue searching\n\t\t\toffset++\n\t\t}\n\t}\n\n\tIptcFieldMap = {\n\t\t0x78: \"caption\",\n\t\t0x6e: \"credit\",\n\t\t0x19: \"keywords\",\n\t\t0x37: \"dateCreated\",\n\t\t0x50: \"byline\",\n\t\t0x55: \"bylineTitle\",\n\t\t0x7a: \"captionWriter\",\n\t\t0x69: \"headline\",\n\t\t0x74: \"copyright\",\n\t\t0x0f: \"category\",\n\t}\n\n\treadIPTCData(file, startOffset, sectionLength) {\n\t\tlet data = {}\n\t\tlet dataView = new DataView(file)\n\t\tlet segmentStartPos = startOffset\n\t\tlet fieldValue, fieldName, dataSize, segmentType, segmentSize\n\n\t\twhile (segmentStartPos < startOffset + sectionLength) {\n\t\t\tif (\n\t\t\t\tdataView.getUint8(segmentStartPos) === 0x1c &&\n\t\t\t\tdataView.getUint8(segmentStartPos + 1) === 0x02\n\t\t\t) {\n\t\t\t\tsegmentType = dataView.getUint8(segmentStartPos + 2)\n\n\t\t\t\tif (segmentType in IptcFieldMap) {\n\t\t\t\t\tdataSize = dataView.getInt16(segmentStartPos + 3)\n\t\t\t\t\tsegmentSize = dataSize + 5\n\t\t\t\t\tfieldName = IptcFieldMap[segmentType]\n\t\t\t\t\tfieldValue = getStringFromDB(\n\t\t\t\t\t\tdataView,\n\t\t\t\t\t\tsegmentStartPos + 5,\n\t\t\t\t\t\tdataSize\n\t\t\t\t\t)\n\n\t\t\t\t\t// Check if we already stored a value with this name\n\t\t\t\t\tif (data.hasOwnProperty(fieldName)) {\n\t\t\t\t\t\t// Value already stored with this name, create multivalue field\n\t\t\t\t\t\tif (data[fieldName] instanceof Array) {\n\t\t\t\t\t\t\tdata[fieldName].push(fieldValue)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[fieldName] = [data[fieldName], fieldValue]\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[fieldName] = fieldValue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegmentStartPos++\n\t\t}\n\n\t\treturn data\n\t}\n\n\treadTags(file, tiffStart, dirStart, strings, bigEnd) {\n\t\tlet entries = file.getUint16(dirStart, !bigEnd),\n\t\t\ttags = {},\n\t\t\tentryOffset,\n\t\t\ttag,\n\t\t\ti\n\n\t\tfor (i = 0; i < entries; i++) {\n\t\t\tentryOffset = dirStart + i * 12 + 2\n\t\t\ttag = strings[file.getUint16(entryOffset, !bigEnd)]\n\n\t\t\tif (!tag && debug) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\ttags[tag] = readTagValue(\n\t\t\t\tfile,\n\t\t\t\tentryOffset,\n\t\t\t\ttiffStart,\n\t\t\t\tdirStart,\n\t\t\t\tbigEnd\n\t\t\t)\n\t\t}\n\n\t\treturn tags\n\t}\n\n\treadTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n\t\tlet type = file.getUint16(entryOffset + 2, !bigEnd),\n\t\t\tnumValues = file.getUint32(entryOffset + 4, !bigEnd),\n\t\t\tvalueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart,\n\t\t\toffset,\n\t\t\tvals,\n\t\t\tval,\n\t\t\tn,\n\t\t\tnumerator,\n\t\t\tdenominator\n\n\t\tswitch (type) {\n\t\t\tcase 1: // byte, 8-bit unsigned int\n\t\t\tcase 7: // undefined, 8-bit byte, value depending on field\n\t\t\t\tif (numValues == 1) {\n\t\t\t\t\treturn file.getUint8(entryOffset + 8, !bigEnd)\n\t\t\t\t} else {\n\t\t\t\t\toffset = numValues > 4 ? valueOffset : entryOffset + 8\n\t\t\t\t\tvals = []\n\n\t\t\t\t\tfor (n = 0; n < numValues; n++) {\n\t\t\t\t\t\tvals[n] = file.getUint8(offset + n)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn vals\n\t\t\t\t}\n\n\t\t\tcase 2: // ascii, 8-bit byte\n\t\t\t\toffset = numValues > 4 ? valueOffset : entryOffset + 8\n\n\t\t\t\treturn getStringFromDB(file, offset, numValues - 1)\n\n\t\t\tcase 3: // short, 16 bit int\n\t\t\t\tif (numValues == 1) {\n\t\t\t\t\treturn file.getUint16(entryOffset + 8, !bigEnd)\n\t\t\t\t} else {\n\t\t\t\t\toffset = numValues > 2 ? valueOffset : entryOffset + 8\n\t\t\t\t\tvals = []\n\n\t\t\t\t\tfor (n = 0; n < numValues; n++) {\n\t\t\t\t\t\tvals[n] = file.getUint16(offset + 2 * n, !bigEnd)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn vals\n\t\t\t\t}\n\n\t\t\tcase 4: // long, 32 bit int\n\t\t\t\tif (numValues == 1) {\n\t\t\t\t\treturn file.getUint32(entryOffset + 8, !bigEnd)\n\t\t\t\t} else {\n\t\t\t\t\tvals = []\n\n\t\t\t\t\tfor (n = 0; n < numValues; n++) {\n\t\t\t\t\t\tvals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn vals\n\t\t\t\t}\n\n\t\t\tcase 5: // rational = two long values, first is numerator, second is denominator\n\t\t\t\tif (numValues == 1) {\n\t\t\t\t\tnumerator = file.getUint32(valueOffset, !bigEnd)\n\t\t\t\t\tdenominator = file.getUint32(valueOffset + 4, !bigEnd)\n\n\t\t\t\t\tval = new Number(numerator / denominator)\n\n\t\t\t\t\tval.numerator = numerator\n\t\t\t\t\tval.denominator = denominator\n\n\t\t\t\t\treturn val\n\t\t\t\t} else {\n\t\t\t\t\tvals = []\n\n\t\t\t\t\tfor (n = 0; n < numValues; n++) {\n\t\t\t\t\t\tnumerator = file.getUint32(valueOffset + 8 * n, !bigEnd)\n\t\t\t\t\t\tdenominator = file.getUint32(\n\t\t\t\t\t\t\tvalueOffset + 4 + 8 * n,\n\t\t\t\t\t\t\t!bigEnd\n\t\t\t\t\t\t)\n\t\t\t\t\t\tvals[n] = new Number(numerator / denominator)\n\t\t\t\t\t\tvals[n].numerator = numerator\n\t\t\t\t\t\tvals[n].denominator = denominator\n\t\t\t\t\t}\n\n\t\t\t\t\treturn vals\n\t\t\t\t}\n\n\t\t\tcase 9: // slong, 32 bit signed int\n\t\t\t\tif (numValues == 1) {\n\t\t\t\t\treturn file.getInt32(entryOffset + 8, !bigEnd)\n\t\t\t\t} else {\n\t\t\t\t\tvals = []\n\n\t\t\t\t\tfor (n = 0; n < numValues; n++) {\n\t\t\t\t\t\tvals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn vals\n\t\t\t\t}\n\n\t\t\tcase 10: // signed rational, two slongs, first is numerator, second is denominator\n\t\t\t\tif (numValues == 1) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tfile.getInt32(valueOffset, !bigEnd) /\n\t\t\t\t\t\tfile.getInt32(valueOffset + 4, !bigEnd)\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tvals = []\n\n\t\t\t\t\tfor (n = 0; n < numValues; n++) {\n\t\t\t\t\t\tvals[n] =\n\t\t\t\t\t\t\tfile.getInt32(valueOffset + 8 * n, !bigEnd) /\n\t\t\t\t\t\t\tfile.getInt32(valueOffset + 4 + 8 * n, !bigEnd)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn vals\n\t\t\t\t}\n\t\t}\n\t}\n\n\tgetStringFromDB(buffer, start, length) {\n\t\tlet outstr = \"\"\n\n\t\tfor (n = start; n < start + length; n++) {\n\t\t\toutstr += String.fromCharCode(buffer.getUint8(n))\n\t\t}\n\n\t\treturn outstr\n\t}\n\n\treadEXIFData(file, start) {\n\t\tif (getStringFromDB(file, start, 4) != \"Exif\") {\n\t\t\tif (debug) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t\"Not valid EXIF data! \" + getStringFromDB(file, start, 4)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\n\t\tlet bigEnd,\n\t\t\ttags,\n\t\t\ttag,\n\t\t\texifData,\n\t\t\tgpsData,\n\t\t\ttiffOffset = start + 6\n\n\t\t// test for TIFF validity and endianness\n\t\tif (file.getUint16(tiffOffset) == 0x4949) {\n\t\t\tbigEnd = false\n\t\t} else if (file.getUint16(tiffOffset) == 0x4d4d) {\n\t\t\tbigEnd = true\n\t\t} else {\n\t\t\tif (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\")\n\n\t\t\treturn false\n\t\t}\n\n\t\tif (file.getUint16(tiffOffset + 2, !bigEnd) != 0x002a) {\n\t\t\tif (debug) console.log(\"Not valid TIFF data! (no 0x002A)\")\n\t\t\treturn false\n\t\t}\n\n\t\tlet firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd)\n\n\t\tif (firstIFDOffset < 0x00000008) {\n\t\t\tif (debug)\n\t\t\t\tconsole.log(\n\t\t\t\t\t\"Not valid TIFF data! (First offset less than 8)\",\n\t\t\t\t\tfile.getUint32(tiffOffset + 4, !bigEnd)\n\t\t\t\t)\n\t\t\treturn false\n\t\t}\n\n\t\ttags = readTags(\n\t\t\tfile,\n\t\t\ttiffOffset,\n\t\t\ttiffOffset + firstIFDOffset,\n\t\t\tTiffTags,\n\t\t\tbigEnd\n\t\t)\n\n\t\tif (tags.ExifIFDPointer) {\n\t\t\texifData = this.readTags(\n\t\t\t\tfile,\n\t\t\t\ttiffOffset,\n\t\t\t\ttiffOffset + tags.ExifIFDPointer,\n\t\t\t\tExifTags,\n\t\t\t\tbigEnd\n\t\t\t)\n\n\t\t\tfor (tag in exifData) {\n\t\t\t\tswitch (tag) {\n\t\t\t\t\tcase \"LightSource\":\n\t\t\t\t\tcase \"Flash\":\n\t\t\t\t\tcase \"MeteringMode\":\n\t\t\t\t\tcase \"ExposureProgram\":\n\t\t\t\t\tcase \"SensingMethod\":\n\t\t\t\t\tcase \"SceneCaptureType\":\n\t\t\t\t\tcase \"SceneType\":\n\t\t\t\t\tcase \"CustomRendered\":\n\t\t\t\t\tcase \"WhiteBalance\":\n\t\t\t\t\tcase \"GainControl\":\n\t\t\t\t\tcase \"Contrast\":\n\t\t\t\t\tcase \"Saturation\":\n\t\t\t\t\tcase \"Sharpness\":\n\t\t\t\t\tcase \"SubjectDistanceRange\":\n\t\t\t\t\tcase \"FileSource\":\n\t\t\t\t\t\texifData[tag] = StringValues[tag][exifData[tag]]\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"ExifVersion\":\n\t\t\t\t\tcase \"FlashpixVersion\":\n\t\t\t\t\t\texifData[tag] = String.fromCharCode(\n\t\t\t\t\t\t\texifData[tag][0],\n\t\t\t\t\t\t\texifData[tag][1],\n\t\t\t\t\t\t\texifData[tag][2],\n\t\t\t\t\t\t\texifData[tag][3]\n\t\t\t\t\t\t)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"ComponentsConfiguration\":\n\t\t\t\t\t\texifData[tag] =\n\t\t\t\t\t\t\tStringValues.Components[exifData[tag][0]] +\n\t\t\t\t\t\t\tStringValues.Components[exifData[tag][1]] +\n\t\t\t\t\t\t\tStringValues.Components[exifData[tag][2]] +\n\t\t\t\t\t\t\tStringValues.Components[exifData[tag][3]]\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ttags[tag] = exifData[tag]\n\t\t\t}\n\t\t}\n\n\t\tif (tags.GPSInfoIFDPointer) {\n\t\t\tgpsData = this.readTags(\n\t\t\t\tfile,\n\t\t\t\ttiffOffset,\n\t\t\t\ttiffOffset + tags.GPSInfoIFDPointer,\n\t\t\t\tGPSTags,\n\t\t\t\tbigEnd\n\t\t\t)\n\n\t\t\tfor (tag in gpsData) {\n\t\t\t\tswitch (tag) {\n\t\t\t\t\tcase \"GPSVersionID\":\n\t\t\t\t\t\tgpsData[tag] =\n\t\t\t\t\t\t\tgpsData[tag][0] +\n\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\tgpsData[tag][1] +\n\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\tgpsData[tag][2] +\n\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\tgpsData[tag][3]\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttags[tag] = gpsData[tag]\n\t\t\t}\n\t\t}\n\n\t\treturn tags\n\t}\n\n\tgetData(img, callback) {\n\t\tif (\n\t\t\t(img instanceof Image || img instanceof HTMLImageElement) &&\n\t\t\t!img.complete\n\t\t)\n\t\t\treturn false\n\n\t\tif (!this.imageHasData(img)) {\n\t\t\tthis.getImageData(img, callback)\n\t\t} else {\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(img)\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tgetTag(img, tag) {\n\t\tif (!this.imageHasData(img)) return\n\t\treturn img.exifdata[tag]\n\t}\n\n\tgetAllTags(img) {\n\t\tif (!this.imageHasData(img)) return {}\n\t\tlet a,\n\t\t\tdata = img.exifdata,\n\t\t\ttags = {}\n\t\tfor (a in data) {\n\t\t\tif (data.hasOwnProperty(a)) {\n\t\t\t\ttags[a] = data[a]\n\t\t\t}\n\t\t}\n\t\treturn tags\n\t}\n\n\tpretty(img) {\n\t\tif (!this.imageHasData(img)) return \"\"\n\t\tlet a,\n\t\t\tdata = img.exifdata,\n\t\t\tstrPretty = \"\"\n\t\tfor (a in data) {\n\t\t\tif (data.hasOwnProperty(a)) {\n\t\t\t\tif (typeof data[a] == \"object\") {\n\t\t\t\t\tif (data[a] instanceof Number) {\n\t\t\t\t\t\tstrPretty +=\n\t\t\t\t\t\t\ta +\n\t\t\t\t\t\t\t\" : \" +\n\t\t\t\t\t\t\tdata[a] +\n\t\t\t\t\t\t\t\" [\" +\n\t\t\t\t\t\t\tdata[a].numerator +\n\t\t\t\t\t\t\t\"/\" +\n\t\t\t\t\t\t\tdata[a].denominator +\n\t\t\t\t\t\t\t\"]\\r\\n\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrPretty +=\n\t\t\t\t\t\t\ta + \" : [\" + data[a].length + \" values]\\r\\n\"\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrPretty += a + \" : \" + data[a] + \"\\r\\n\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn strPretty\n\t}\n\n\treadFromBinaryFile(file) {\n\t\treturn this.findEXIFinJPEG(file)\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}