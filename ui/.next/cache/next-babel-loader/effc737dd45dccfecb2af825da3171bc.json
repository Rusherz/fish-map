{"ast":null,"code":"import axios from \"axios\";\nexport function GetLocation(full = false) {\n  return new Promise((resolve, reject) => {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(positon => {\n        if (!full) {\n          let location = {\n            latitude: 0,\n            longitude: 0,\n            accuracy: 0,\n            altitudeAccuracy: 0,\n            altitude: 0,\n            heading: 0,\n            speed: 0\n          };\n\n          for (let key in positon) {\n            location[key] = positon[key];\n          }\n\n          resolve(location);\n          return;\n        }\n\n        resolve(positon);\n      }, error => reject(error));\n    }\n  });\n}\n\nfunction getOptions(options) {\n  // // Get the current state of the client\n  // let state = wrapper\n  // // If we have a user anda session\n  // if (\n  // \tstate.user &&\n  // \tObject.keys(state.user.user).length !== 0 &&\n  // \tObject.keys(state.user.session).length !== 0\n  // ) {\n  // \t// Check if options already has headers,\n  // \t// if not then create a new object\n  // \tif (!options.headers) {\n  // \t\toptions.headers = {}\n  // \t}\n  // \t// Set the user and token header for the server\n  // \toptions.headers[\"x-user-id\"] = state.user.user.id\n  // \toptions.headers[\"x-token\"] = state.user.session.access_token\n  // }\n  // return the options\n  return options;\n}\n\nfunction handleResponse(resolve, reject, options, response) {\n  // Check if something on the server went wrong,\n  // if something did go wrong then reject the promise\n  // and return the message\n  if (response.data.status === false) {\n    reject(response.data.message);\n  } // If nothing went wrong,\n  // check to see if the call wants the full response,\n  // if so resolve the full response,\n\n\n  if (options.full) {\n    resolve(response);\n  } // otherwise resolve only the data of the response\n  else {\n      resolve(response.data);\n    }\n}\n\nexport function get(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.get(url, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}\nexport function post(url, body, options = {}) {\n  return new Promise((resolve, reject) => {\n    // options = getOptions(options)\n    axios.post(url, body, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}\nexport function put(url, body, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.put(url, body, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}","map":{"version":3,"sources":["/Users/austin/dev/fish-maps/ui/classes/Plugins.ts"],"names":["axios","GetLocation","full","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","positon","location","latitude","longitude","accuracy","altitudeAccuracy","altitude","heading","speed","key","error","getOptions","options","handleResponse","response","data","status","message","get","url","then","post","body","put"],"mappings":"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","sourcesContent":["import axios from \"axios\"\n\nexport function GetLocation(full: boolean = false): Promise<Position | Coordinates> {\n\treturn new Promise((resolve, reject) => {\n\t\tif (navigator.geolocation) {\n\t\t\tnavigator.geolocation.getCurrentPosition(\n\t\t\t\t(positon) => {\n\t\t\t\t\tif (!full) {\n\t\t\t\t\t\tlet location: Coordinates = {\n\t\t\t\t\t\t\tlatitude: 0,\n\t\t\t\t\t\t\tlongitude: 0,\n\t\t\t\t\t\t\taccuracy: 0,\n\t\t\t\t\t\t\taltitudeAccuracy: 0,\n\t\t\t\t\t\t\taltitude: 0,\n\t\t\t\t\t\t\theading: 0,\n\t\t\t\t\t\t\tspeed: 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let key in positon) {\n\t\t\t\t\t\t\tlocation[key] = positon[key]\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve(location)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(positon)\n\t\t\t\t},\n\t\t\t\t(error) => reject(error)\n\t\t\t)\n\t\t}\n\t})\n}\n\nfunction getOptions(options) {\n\t// // Get the current state of the client\n\t// let state = wrapper\n\n\t// // If we have a user anda session\n\t// if (\n\t// \tstate.user &&\n\t// \tObject.keys(state.user.user).length !== 0 &&\n\t// \tObject.keys(state.user.session).length !== 0\n\t// ) {\n\t// \t// Check if options already has headers,\n\t// \t// if not then create a new object\n\t// \tif (!options.headers) {\n\t// \t\toptions.headers = {}\n\t// \t}\n\n\t// \t// Set the user and token header for the server\n\t// \toptions.headers[\"x-user-id\"] = state.user.user.id\n\t// \toptions.headers[\"x-token\"] = state.user.session.access_token\n\t// }\n\n\t// return the options\n\treturn options\n}\n\nfunction handleResponse(resolve, reject, options, response) {\n\t// Check if something on the server went wrong,\n\t// if something did go wrong then reject the promise\n\t// and return the message\n\tif (response.data.status === false) {\n\t\treject(response.data.message)\n\t}\n\n\t// If nothing went wrong,\n\t// check to see if the call wants the full response,\n\t// if so resolve the full response,\n\tif (options.full) {\n\t\tresolve(response)\n\t}\n\t// otherwise resolve only the data of the response\n\telse {\n\t\tresolve(response.data)\n\t}\n}\n\nexport function get(url, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.get(url, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n\nexport function post(url, body, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\t// options = getOptions(options)\n\n\t\taxios\n\t\t\t.post(url, body, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n\nexport function put(url, body, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.put(url, body, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n"]},"metadata":{},"sourceType":"module"}