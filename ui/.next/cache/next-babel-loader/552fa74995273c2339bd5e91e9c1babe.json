{"ast":null,"code":"import axios from \"axios\";\nexport function GetLocation() {\n  return new Promise((resolve, reject) => {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(location => resolve(location), error => reject(error));\n    }\n  });\n}\n\nfunction getOptions(options) {\n  // // Get the current state of the client\n  // let state = wrapper\n  // // If we have a user anda session\n  // if (\n  // \tstate.user &&\n  // \tObject.keys(state.user.user).length !== 0 &&\n  // \tObject.keys(state.user.session).length !== 0\n  // ) {\n  // \t// Check if options already has headers,\n  // \t// if not then create a new object\n  // \tif (!options.headers) {\n  // \t\toptions.headers = {}\n  // \t}\n  // \t// Set the user and token header for the server\n  // \toptions.headers[\"x-user-id\"] = state.user.user.id\n  // \toptions.headers[\"x-token\"] = state.user.session.access_token\n  // }\n  // return the options\n  return options;\n}\n\nfunction handleResponse(resolve, reject, options, response) {\n  // Check if something on the server went wrong,\n  // if something did go wrong then reject the promise\n  // and return the message\n  if (response.data.status === false) {\n    reject(response.data.message);\n  } // If nothing went wrong,\n  // check to see if the call wants the full response,\n  // if so resolve the full response,\n\n\n  if (options.full) {\n    resolve(response);\n  } // otherwise resolve only the data of the response\n  else {\n      resolve(response.data);\n    }\n}\n\nexport function get(url, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.get(url, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}\nexport function post(url, body, options = {}) {\n  return new Promise((resolve, reject) => {\n    // options = getOptions(options)\n    axios.post(url, body, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}\nexport function put(url, body, options = {}) {\n  return new Promise((resolve, reject) => {\n    options = getOptions(options);\n    axios.put(url, body, options).then(response => handleResponse(resolve, reject, options, response));\n  });\n}","map":{"version":3,"sources":["/Users/austin/dev/fish-maps/ui/classes/Plugins.ts"],"names":["axios","GetLocation","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","location","error","getOptions","options","handleResponse","response","data","status","message","full","get","url","then","post","body","put"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAO,SAASC,WAAT,GAA0C;AAChD,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,QAAIC,SAAS,CAACC,WAAd,EAA2B;AAC1BD,MAAAA,SAAS,CAACC,WAAV,CAAsBC,kBAAtB,CACEC,QAAD,IAAcL,OAAO,CAACK,QAAD,CADtB,EAEEC,KAAD,IAAWL,MAAM,CAACK,KAAD,CAFlB;AAIA;AACD,GAPM,CAAP;AAQA;;AAED,SAASC,UAAT,CAAoBC,OAApB,EAA6B;AAC5B;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA,SAAOA,OAAP;AACA;;AAED,SAASC,cAAT,CAAwBT,OAAxB,EAAiCC,MAAjC,EAAyCO,OAAzC,EAAkDE,QAAlD,EAA4D;AAC3D;AACA;AACA;AACA,MAAIA,QAAQ,CAACC,IAAT,CAAcC,MAAd,KAAyB,KAA7B,EAAoC;AACnCX,IAAAA,MAAM,CAACS,QAAQ,CAACC,IAAT,CAAcE,OAAf,CAAN;AACA,GAN0D,CAQ3D;AACA;AACA;;;AACA,MAAIL,OAAO,CAACM,IAAZ,EAAkB;AACjBd,IAAAA,OAAO,CAACU,QAAD,CAAP;AACA,GAFD,CAGA;AAHA,OAIK;AACJV,MAAAA,OAAO,CAACU,QAAQ,CAACC,IAAV,CAAP;AACA;AACD;;AAED,OAAO,SAASI,GAAT,CAAaC,GAAb,EAAkBR,OAAO,GAAG,EAA5B,EAAgC;AACtC,SAAO,IAAIT,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvCO,IAAAA,OAAO,GAAGD,UAAU,CAACC,OAAD,CAApB;AAEAX,IAAAA,KAAK,CACHkB,GADF,CACMC,GADN,EACWR,OADX,EAEES,IAFF,CAEQP,QAAD,IACLD,cAAc,CAACT,OAAD,EAAUC,MAAV,EAAkBO,OAAlB,EAA2BE,QAA3B,CAHhB;AAKA,GARM,CAAP;AASA;AAED,OAAO,SAASQ,IAAT,CAAcF,GAAd,EAAmBG,IAAnB,EAAyBX,OAAO,GAAG,EAAnC,EAAuC;AAC7C,SAAO,IAAIT,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC;AAEAJ,IAAAA,KAAK,CACHqB,IADF,CACOF,GADP,EACYG,IADZ,EACkBX,OADlB,EAEES,IAFF,CAEQP,QAAD,IACLD,cAAc,CAACT,OAAD,EAAUC,MAAV,EAAkBO,OAAlB,EAA2BE,QAA3B,CAHhB;AAKA,GARM,CAAP;AASA;AAED,OAAO,SAASU,GAAT,CAAaJ,GAAb,EAAkBG,IAAlB,EAAwBX,OAAO,GAAG,EAAlC,EAAsC;AAC5C,SAAO,IAAIT,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvCO,IAAAA,OAAO,GAAGD,UAAU,CAACC,OAAD,CAApB;AAEAX,IAAAA,KAAK,CACHuB,GADF,CACMJ,GADN,EACWG,IADX,EACiBX,OADjB,EAEES,IAFF,CAEQP,QAAD,IACLD,cAAc,CAACT,OAAD,EAAUC,MAAV,EAAkBO,OAAlB,EAA2BE,QAA3B,CAHhB;AAKA,GARM,CAAP;AASA","sourcesContent":["import axios from \"axios\"\n\nexport function GetLocation(): Promise<Position> {\n\treturn new Promise((resolve, reject) => {\n\t\tif (navigator.geolocation) {\n\t\t\tnavigator.geolocation.getCurrentPosition(\n\t\t\t\t(location) => resolve(location),\n\t\t\t\t(error) => reject(error)\n\t\t\t)\n\t\t}\n\t})\n}\n\nfunction getOptions(options) {\n\t// // Get the current state of the client\n\t// let state = wrapper\n\n\t// // If we have a user anda session\n\t// if (\n\t// \tstate.user &&\n\t// \tObject.keys(state.user.user).length !== 0 &&\n\t// \tObject.keys(state.user.session).length !== 0\n\t// ) {\n\t// \t// Check if options already has headers,\n\t// \t// if not then create a new object\n\t// \tif (!options.headers) {\n\t// \t\toptions.headers = {}\n\t// \t}\n\n\t// \t// Set the user and token header for the server\n\t// \toptions.headers[\"x-user-id\"] = state.user.user.id\n\t// \toptions.headers[\"x-token\"] = state.user.session.access_token\n\t// }\n\n\t// return the options\n\treturn options\n}\n\nfunction handleResponse(resolve, reject, options, response) {\n\t// Check if something on the server went wrong,\n\t// if something did go wrong then reject the promise\n\t// and return the message\n\tif (response.data.status === false) {\n\t\treject(response.data.message)\n\t}\n\n\t// If nothing went wrong,\n\t// check to see if the call wants the full response,\n\t// if so resolve the full response,\n\tif (options.full) {\n\t\tresolve(response)\n\t}\n\t// otherwise resolve only the data of the response\n\telse {\n\t\tresolve(response.data)\n\t}\n}\n\nexport function get(url, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.get(url, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n\nexport function post(url, body, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\t// options = getOptions(options)\n\n\t\taxios\n\t\t\t.post(url, body, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n\nexport function put(url, body, options = {}) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = getOptions(options)\n\n\t\taxios\n\t\t\t.put(url, body, options)\n\t\t\t.then((response) =>\n\t\t\t\thandleResponse(resolve, reject, options, response)\n\t\t\t)\n\t})\n}\n"]},"metadata":{},"sourceType":"module"}